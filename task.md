3. Требования к сервису
3.1. Функциональные требования
Сервис должен представлять собой REST API, который получает на вход задачу
анализа структуры базы данных (далее БД). Такой анализ не может быть выполнен
синхронно, поэтому в ответ ожидается некоторый номер задачи и статус готовности,
который можно запрашивать асинхронно. По готовности задача должна иметь
возможность получить результат.
Такие требования приводят к следующему набору REST API-запросов:
Запрос Описание
POST https://<endpoint>/new Запуск задачи (формат запроса
ниже)
GET https://<endpoint>/status?<task_id> Запрос статуса задачи
GET https://<endpoint>/getresult?<task_id> Запрос на получение
результатов.
3.2. Форматы запросов.
Запрос на запуск задачи.
Данные для запуска представляют собой три элемента:
● DDL создания таблиц. Скрипт разбивается на отдельные запросы для создания
каждой отдельной таблицы.
● Набор запросов со статистикой по количеству вызовов каждого. Каждый
запрос имеет идентификатор, который позволит в дальнейшем оценить изменение
скорости работы.
● Строка подключения в формате jdbc с логином и паролем для оценки самих
данных.
Формат запроса:
{
"url":"jdbc://some-endpoint/database?login=xxx&password=yyyy",
"ddl":[
{
"statement": "CREATE TABLE Table1.........",
},
{
"statement": "CREATE TABLE SecondTable.........",
},
],
"queries": [
{
"queryid":"0197a0b2-2284-7af8-9012-fcb21e1a9785",
"query":"SELECT a.ID, b.XXX....",
"runquantity": 123
},
{
"queryid":"c8ed3309-1acb-439a-b32b-f802ba41db3e",
"query":"WITH (...",
"runquantity":112233
}
]
}
Ответ на такой запрос должен содержать идентификатор, по которому задача
однозначно определяется сервисом. Пример ответа:
{
"taskid":"6c12bd3f-80b1-4c0a-84ab-d3160d2e8f7a"
}
Запрос статуса задачи.
Ответом на такой запрос должно быть одно поле со статусом выполнения
RUNNING, если запрос еще не закончен, DONE, если можно забирать результаты и
FAILED, если что-то пошло не так, и запуск не удался. Предельное время ожидания
ответа — 20 минут. После этого запрос считается неудавшимся.
Запрос на получение результатов.
В ответ на этот запрос ваш сервис должен вернуть ответ, содержащий следующую
информацию:
● Новый набор DDL-запросов для модификации структуры таблиц.
● Набор запросов для миграции данных.
● Набор запросов с их идентификаторами, которые используют новую структуру
таблиц.
Пример ответа:
{
"ddl":[
{
},
{
"statement":"CREATE TABLE t1..."
"statement":"CREATE TABLE T2..."
}
],
"migrations":[
{
},
{
"statement":"INSERT INTO T1 SELECT * FROM OldT1 LEFT JOIN ..."
"statement":"INSERT INTO T2 SELECT..."
}
],
"queries":[
{
"queryid":"0197a0b2-2284-7af8-9012-fcb21e1a9785",
"query":"WITH (..."
},
{
"queryid":"c8ed3309-1acb-439a-b32b-f802ba41db3e",
"query":"WITH (..."
}
]
}
ВНИМАНИЕ!
Все команды работы с таблицами должны использовать полный путь к таблице в
формате <каталог>.<схема>.<таблица>. В вашем ответе первой DDL командой
должна идти команда создания новой схемы в этом же каталоге!
Пример:
CREATE SCHEMA data.NewSchema
Все SQL запросы, которые переносят данные в новую структуру также должны
придерживаться этого правила полной идентификации таблиц, пример:
INSERT INTO catalog.myschema.h_authors
SELECT * FROM catalog.public.h_authors
Все запросы к новой структуре данных должны также указывать полный путь в
новой схеме, пример:
SELECT a.Col1, a.Col2, b.Col4
FROM catalog.myschema.MyTable1 as a
JOIN catalog.myschema.MyTable2 as b on a.ID=b.ID
4. Возможный пользовательский путь
1. Осуществляется сбор информации по количеству запросов, среднему времени
их выполнения и объема данных в хранилище.
2. С помощью сервиса генерируется предложение по изменению структуры БД и
запросов.
3. Пользователь тестирует данное предложение и разрабатывает план миграции
на его основе.